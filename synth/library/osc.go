package library

import (
	"math"

	"github.com/go-audio/audio"
)

// Osc is an oscillator
type Osc struct {
	Shape     WaveType
	Amplitude float32
	DcOffset  float32
	Freq      float32
	// SampleRate
	Fs                int
	PhaseOffset       float32
	CurrentPhaseAngle float32
	phaseAngleIncr    float32
	// currentSample allows us to track where we are at in the signal life
	// and setup an envelope accordingly
	currentSample int
	// ADSR
	attackInSamples int
}

// NewOsc returns a new oscillator, note that if you change the phase offset of the returned osc,
// you also need to set the CurrentPhaseAngle
func NewOsc(shape WaveType, hz float32, fs int) *Osc {
	return &Osc{Shape: shape, Amplitude: 1, Freq: hz, Fs: fs, phaseAngleIncr: ((hz * TwoPi) / float32(fs))}
}

// Reset sets the oscillator back to its starting state
func (o *Osc) Reset() {
	o.phaseAngleIncr = ((o.Freq * TwoPi) / float32(o.Fs))
	o.currentSample = 0
}

// SetFreq updates the oscillator frequency
func (o *Osc) SetFreq(hz float32) {
	if o.Freq != hz {
		o.Freq = hz
		o.phaseAngleIncr = ((hz * TwoPi) / float32(o.Fs))
	}
}

// SetAttackInMs sets the duration for the oscillator to be at full amplitude
// after it starts.
func (o *Osc) SetAttackInMs(ms int) {
	if o == nil {
		return
	}
	if ms <= 0 {
		o.attackInSamples = 0
		return
	}
	o.attackInSamples = int(float32(o.Fs) / (1000.0 / float32(ms)))
}

// Signal uses the osc to generate a discreet signal
func (o *Osc) Signal(length int) []float32 {
	output := make([]float32, length)
	for i := 0; i < length; i++ {
		output[i] = o.Sample()
	}
	return output
}

// Fill fills up the pass audio Buffer with the output of the oscillator.
func (o *Osc) Fill(buf *audio.Float32Buffer) error {
	if o == nil {
		return nil
	}
	numChans := 1
	if f := buf.Format; f != nil {
		numChans = f.NumChannels
	}
	frameCount := buf.NumFrames()
	var sample float32
	for i := 0; i < frameCount; i++ {
		sample = o.Sample()
		for j := 0; j < numChans; j++ {
			buf.AsFloat32Buffer().Data[i*numChans+j] = sample
		}
	}
	return nil
}

// Sample returns the next sample generated by the oscillator
func (o *Osc) Sample() (output float32) {
	if o == nil {
		return
	}
	o.currentSample++
	if o.CurrentPhaseAngle < -math.Pi {
		o.CurrentPhaseAngle += TwoPi
	} else if o.CurrentPhaseAngle > math.Pi {
		o.CurrentPhaseAngle -= TwoPi
	}

	var amp float32
	if o.attackInSamples > o.currentSample {
		// linear fade in
		amp = float32(o.currentSample) * (o.Amplitude / float32(o.attackInSamples))
	} else {
		amp = o.Amplitude
	}

	switch o.Shape {
	case WaveSine:
		output = amp*Sine(o.CurrentPhaseAngle) + o.DcOffset
	case WaveTriangle:
		output = amp*Triangle(o.CurrentPhaseAngle) + o.DcOffset
	case WaveSaw:
		output = amp*Sawtooth(o.CurrentPhaseAngle) + o.DcOffset
	case WaveSqr:
		output = amp*Square(o.CurrentPhaseAngle) + o.DcOffset
	case WaveNoise:
		output = amp*Noise(o.CurrentPhaseAngle) + o.DcOffset
	}

	o.CurrentPhaseAngle += o.phaseAngleIncr
	return output
}
